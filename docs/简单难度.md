# LeetCode刷题（简单难度）
## [1.两数之和](https://leetcode-cn.com/problems/two-sum/description/)

    给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
    你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

示例：

    给定 nums = [2, 7, 11, 15], target = 9
    因为 nums[0] + nums[1] = 2 + 7 = 9
    所以返回 [0, 1]

代码（JavaScript）
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let i = 0, j = i + 1
    while(nums[i] + nums[j] !== target || j >= nums.length || i >= nums.length-1) {
        j++
        if (j === nums.length) {
            i++
            j = i + 1
        }
    }
    return [i, j]
};
```

## [2.反转整数](https://leetcode-cn.com/problems/reverse-integer/description/)

    给定一个 32 位有符号整数，将整数中的数字进行反转。
    假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。

示例：

    输入: 123
    输出: 321
    
    输入: -123
    输出: -321
    
代码（JavaScript）
```javascript
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    const isF = x < 0
    const num = Number(String(Math.abs(x)).split('').reverse().join(''))
    if ((!isF && num > Math.pow(2, 31)-1) || (isF && -num < -Math.pow(2, 31))) {
        return 0
    }
    return isF ? -num : num
};
```

## [3.回文数](https://leetcode-cn.com/problems/palindrome-number/description/)

    判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例：

    输入: 121
    输出: true
    
    输入: -121
    输出: false
    解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
    
代码：
```javascript
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    if (x === 0) return true
    else if (x < 0) return false
    else return String(x) === String(x).split('').reverse().join('')
};
```

## [4.最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/description/)

    编写一个函数来查找字符串数组中的最长公共前缀。
    如果不存在公共前缀，返回空字符串 ""。
    
示例：

    输入: ["flower","flow","flight"]
    输出: "fl"
    
```javascript
/**
 * @param {string[]} strs
 * @return {string}
 */
function deep (arr, tmp, len, pre) {
    if (arr.every(v => v.substr(0, tmp.length) === tmp) && len >= 0) {
        pre.push(tmp)
        return deep(arr, arr[0].substr(0, tmp.length + 1), --len, pre)
    }
    return pre[pre.length - 1]
}
var longestCommonPrefix = function(strs) {
    if (strs.length === 0) return ""
    const len = Math.min(...strs.map(v => v.length))
    return deep(strs, "", len, [])
};
```

## [5.有效的括号](https://leetcode-cn.com/problems/valid-parentheses/description/)

    给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
    有效字符串需满足：
    
    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。
    注意空字符串可被认为是有效字符串。

示例：

    输入: "()[]{}"
    输出: true

    输入: "([)]"
    输出: false

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
function clear (s) {
    const str = s.replace(/(\[\]|\{\}|\(\))/g, '')
    if (str.length !== 0 && str !== s) return clear(str)
    return str
}
var isValid = function(s) {
    return clear(s) === ""
};
```

## [6.加一](https://leetcode-cn.com/problems/plus-one/description/)

    给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
    最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。
    你可以假设除了整数 0 之外，这个整数不会以零开头。

示例：

    输入: [1,2,3]
    输出: [1,2,4]

    输入: [0,0,1]
    输出: [0,0,2]
    
    输入: [9,9,9]
    输出: [1,0,0,0]

代码（JavaScript）
```javascript
/**
 * @param {number[]} digits
 * @return {number[]}
 */
// 难度很小，唯一的坑就是如果把数组转成number+1的话，数字过大JavaScript无法精确计算，导致出错
var plusOne = function(digits) {
    if (digits.length === 0) return [1]
    const last = digits.length - 1
    digits[last]++
    for (let i=last; i>0; i--) {
        if (digits[i] === 10) {
            digits[i] = 0
            digits[i-1]++
        }
    }
    if (digits[0] === 10) {
        digits[0] = 0
        digits.unshift(1)
    }
    return digits
};
```

## [7.只出现一次的数字](https://leetcode-cn.com/problems/single-number/description/)

    给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
    你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例：

    输入: [2,2,1]
    输出: 1

代码（JavaScript）
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    return nums.filter(v => nums.indexOf(v) === nums.lastIndexOf(v))[0]
};
```
代码2（JavaScript）
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    const obj = nums.reduce((o, k) => (o[k] ? o[k]++ : (o[k] = 1), o), {})
    for (let i in obj) {
        if (obj[i] === 1) {
            return Number(i)
        }
    }
};
```


作者：微博 [@itagn][1] - Github [@itagn][2]

[1]: https://weibo.com/p/1005053782707172
[2]: https://github.com/itagn
