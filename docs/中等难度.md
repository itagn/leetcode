# LeetCode刷题（中等难度）
## [1.两数相加](https://leetcode-cn.com/problems/add-two-numbers/description/)

    给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。
    你可以假设除了数字 0 之外，这两个数字都不会以零开头。

示例：

    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
    输出：7 -> 0 -> 8
    原因：342 + 465 = 807

代码（JavaScript）
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
function getArr (list, arr) {
    arr.push(list.val)
    if (list.next !== null) return getArr(list.next, arr)
    return arr
}
function getNewList (list, arr) {
    list.next = new ListNode(+arr.splice(0, 1)[0])
    if (arr.length !== 0) getNewList(list.next, arr)
    return list
}
var addTwoNumbers = function(l1, l2) {
    const arr1 = getArr(l1, []), arr2 = getArr(l2, [])
    const len = Math.min(arr1.length, arr2.length)
    const result = []
    for (let i=0; i<len; i++) {
        result.push(arr1[i] + arr2[i])
    }
    arr1.length === len ? result.push(...arr2.slice(len)) : result.push(...arr1.slice(len))
    for (let i=0; i<result.length; i++) {
        if (result[i] > 9) {
            result[i] = result[i] % 10
            result[i+1] = i < result.length-1 ? result[i+1] + 1 : 1
        }
    }
    return result.length === 1 ? new ListNode(+result) : getNewList(new ListNode(+result[0]), result.slice(1))
};
```

## [2.无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/)

    给定一个字符串，找出不含有重复字符的最长子串的长度。
    
示例：

    输入: "pwwkew"
    输出: 3
    解释: 无重复字符的最长子串是 "wke"，其长度为 3。
        请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。

代码（JavaScript）
```javascript
/**
 * @param {string} s
 * @return {number}
 */
function isNoRepeat(str) {
    return str.length === [...new Set(str.split(''))].length
}
var lengthOfLongestSubstring = function(s) {
    // 最长的不重复字符串是95个字符，所以长度上限是95
    const len = s.length > 95 ? 95 : s.length
    for (let i=len; i>0; i--) {
        for (let j=0; j<s.length-i+1; j++) {
            const str = s.substr(j, i)
            if (isNoRepeat(str)) {
                return str.length
            }
        }
    }
    return 0
};
```
代码2（JavaScript）
```javascript
/**
 * @param {string} s
 * @return {number}
 */
function isNoRepeat(str) {
    return str.length === [...new Set(str.split(''))].length
}
var lengthOfLongestSubstring = function(s) {
    // 最长的不重复字符串是95个字符，所以长度上限是95
    let i = s.length > 95 ? 95 : s.length, j = 0
    while (i > 0 || j < s.length-i+1) {
        const str = s.substr(j, i)
        if (isNoRepeat(str)) {
            return str.length
        }
        if (i + j >= s.length) {
            i--
            j = 0
        } else {
            j++
        } 
    }
    return 0
};
```

## [3.最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/description/)

    给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。
    
示例：

    输入: "babad"
    输出: "bab"
    注意: "aba"也是一个有效答案。

代码（JavaScript）
```javascript
/**
 * @param {string} s
 * @return {string}
 */
function isPalindromic (str, i) {
    // 匹配第一位和最后一位
    let bool = str[i-1] === str[str.length-i]
    // 如果不匹配直接输出结果
    if (!bool) return false
    if (str.length > 2 * i + 1) {
        // 如果长度够，继续匹配
        bool = bool && isPalindromic(str.slice(i, str.length-i), i++)
    }
    return bool
}
var longestPalindrome = function(s) {
    for (let i=s.length; i>0; i--) {
        for (let j=0; j<s.length-i+1; j++) {
            const str = s.substr(j, i)
            if (isPalindromic(str, 1)) {
                return str
            }
        }
    }
    return ''
};
```

## [4.全排列](https://leetcode-cn.com/problems/permutations/description/)

    给定一个没有重复数字的序列，返回其所有可能的全排列。
    
示例：

    输入: [1,2,3]
    输出:
    [
      [1,2,3],
      [1,3,2],
      [2,1,3],
      [2,3,1],
      [3,1,2],
      [3,2,1]
    ]
    
代码（JavaScript）
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
function allSort (arr) {
    if (arr.length <= 1) return arr
    const result = []
    for (let i=0; i<arr.length; i++) {
        const temp = [...arr]
        const prev = temp.splice(i, 1)[0]
        const next = allSort(temp)
        for (let j=0; j<next.length; j++) {
            const data = prev + ',' + next[j]
            if (!result.includes[data]) result.push(data)
        }
    }
    return [...new Set(result)]
}
var permute = function(nums) {
    if (nums.length <= 1) return [nums]
    const result = allSort(nums).map(val => val.split(',').map(v => {
        if (isNaN(Number(v))) return -(Number(v.slice(1)))
        else return Number(v)
    }))
    return result
};
```

## [5.全排列 II](https://leetcode-cn.com/problems/permutations-ii/description/)

    给定一个可包含重复数字的序列，返回所有不重复的全排列。
    
示例：

    输入: [1,1,2]
    输出:
    [
      [1,1,2],
      [1,2,1],
      [2,1,1]
    ]

代码（JavaScript）
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
function allSort (arr) {
    if (arr.length <= 1) return arr
    const result = []
    for (let i=0; i<arr.length; i++) {
        const temp = [...arr]
        const prev = temp.splice(i, 1)[0]
        const next = allSort(temp)
        for (let j=0; j<next.length; j++) {
            const data = prev + ',' + next[j]
            if (!result.includes[data]) result.push(data)
        }
    }
    return [...new Set(result)]
}
var permuteUnique = function(nums) {
    // 与上一个全排列的区别在于如何处理 空数组
    if (nums.length === 0) return []
    if (nums.length === 1) return [nums]
    const result = allSort(nums).map(val => val.split(',').map(v => {
        if (isNaN(Number(v))) return -(Number(v.slice(1)))
        else return Number(v)
    }))
    return result
};
```

作者：微博 [@itagn][1] - Github [@itagn][2]

[1]: https://weibo.com/p/1005053782707172
[2]: https://github.com/itagn
